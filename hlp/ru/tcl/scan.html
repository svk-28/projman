<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
    <head>
      <title>scan</title>
    </head>
  <body>
    <h1>scan</h1>

    <p>Производит разбор строки в стиле процедуры <strong>sscanf</strong>.</p>

    <h2>СИНТАКСИС</h2> 

    <pre>
      <strong>scan</strong> <em>string</em> <em>format</em> <em>varName</em> ?<em>varName</em>...?
    </pre>

    <h2>ВВЕДЕНИЕ</h2> 

    <p>Данная команда, подобно ANSI C процедуре <strong>sscanf</strong>,
      просматривает строку <em>string</em>, выбирает поля и преобразует
      их в соответствии с очередным спецификатором преобразования в
      строке <em>format</em>. Выбранные значения преобразуются обратно в
      строковый вид и последовательно записываются в переменные
      <em>varName</em>.</p>

    <h2>ПРОЦЕСС СКАНИРОВАНИЯ</h2> 

    <p>Команда <strong>scan</strong> просматривает одновременно строки
      <em>string</em> и <em>format</em>. Если очередной символ в строке
      <em>format</em> пробел или табуляция, то он соответствует любому
      числу (включая ноль) пробельных символов (пробел, табуляция,
      новая строка) в строке <em>string</em>. Если в строке
      <em>format</em> встретился символ <strong>%</strong>, он означает начало
      очередного спецификатора преобразования.  Спецификатор
      преобразования включает в себя до трех полей после символа
      <strong>%</strong>: первое поле может содержать символ <strong>*</strong>,
      означающий, что преобразуемая величина будет удалена, а не
      записана в очередную переменную, второе поле может содержать
      число, указывающее максимальную ширину поля, и третье поле
      содержит букву, определяющую тип преобразования. Обязательным
      является только третье поле.</p>

    <p>Когда команда <strong>scan</strong> находит спецификатор
      преобразования в строке <em>format</em>, она пропускает
      пробельные символы в строке <em>string</em>. Затем она выбирает
      следующую группу непробельных символов и преобразует их в
      соответствии со спецификатором преобразования и записывает
      результат в переменную, соответствующую следующему аргументу
      команды. Поддерживаются следующие типы преобразований,
      задаваемые соответствующими символами:</p>

    <dl>
      <dt><strong>d</strong></dt>

      <dd>Входное поле должно быть десятичным числом. Результат
        записывается как десятичная строка.</dd>

      <dt><strong>o</strong></dt> 

      <dd>Входное поле должно быть восьмеричным числом. Результат
        преобразуется в десятичную строку.</dd>

      <dt><strong>x</strong></dt> 

      <dd>Входное поле должно быть шестнадцатеричным числом.
        Результат преобразуется в десятичную строку.</dd>

      <dt><strong>c</strong></dt> 

      <dd>Читается один символ, его двоичная величина преобразуется и
        записывается в переменную как десятичная строка. Начальные
        пробельные символы в этом случае не пропускаются. В отличие от
        ANSI C процедуры <strong>sscanf</strong> входное поле всегда состоит
        ровно из одного символа, а ширина поля не может быть
        задана.</dd>

      <dt><strong>s</strong></dt>

      <dd>Входное поле состоит из всех непробельных символов до
	следующего пробельного. Все символы копируются в
	переменную.</dd>

      <dt><strong>e</strong> или <strong>f</strong> или <strong>g</strong></dt>

      <dd>Входное поле должно быть числом с плавающей точкой,
        состоящим из знака (не обязательно), строки десятичных цифр,
        возможно с десятичной точкой и порядка (не обязательно),
        состоящего из буквы <strong>e</strong> или <strong>E</strong>, знака порядка (не
        обязательно) и строки десятичных цифр.</dd>

      <dt><strong>[<em>chars</em>]</strong></dt>

      <dd>Входное поле состоит из произвольного числа символов из
	<em>chars</em>. Соответствующая строка записывается в
	переменную. Если первый символ в скобках <strong>]</strong>, то он
	рассматривается как часть <em>chars</em>, а не как закрывающая
	скобка для множества символов.</dd>

      <dt><strong>[^<em>chars</em>]</strong></dt>

      <dd>Входное поле состоит из произвольного числа символов, не
        содержащихся в <em>chars</em>. Соответствующая строка
        записывается в переменную. Если первый символ в скобках после
        <strong>^</strong> есть <strong>]</strong>, то он рассматривается как
        часть <em>chars</em>, а не как закрывающая скобка для множества
        символов.</dd>
    </dl>

    <p>Число символов, которое выбирается для преобразования, это
      максимально возможное число символов для соответствующего
      преобразования (например, так много десятичных цифр, как это
      возможно для <strong>%d</strong>, или так много восьмеричных цифр, как это
      возможно для <strong>%o</strong>). Поле, выбираемое для очередного
      преобразования, закрывается, как только в строке <em>string</em>
      встречается пробельный символ или как только поле достигает
      указанного максимального размера (в зависимости от того, что
      происходит раньше). Если в спецификаторе преобразования для
      очередного поля присутствует символ <strong>*</strong>, то выбранное
      значение не присваивает никакой переменной, а очередной аргумент
      команды <strong>scan</strong> по-прежнему считается неиспользованным.</p>

    <h2>ОТЛИЧИЯ ОТ ANSI SSCANF</h2> 

    <p>Поведение команды <strong>scan</strong> не отличается от поведения ANSI
      C процедуры <strong>sscanf</strong> за исключением следующих моментов:</p>
    <table>
	<tr>
	  <td>[1]</td>
	  <td>Спецификаторы <strong>%p</strong> и <strong>%n</strong> не поддерживаются.</td>
	</tr>
	<tr>
	  <td>[2]</td>
	  <td>Для спецификатора <strong>%c</strong> нельзя указывать ширину
	    поля.  Только один символ переводится в десятичную
	    величину, которая и присваивается соответствующей
	    переменной.</td>
	</tr>
	<tr>
	  <td>[3]</td>
	  <td>Модификаторы <strong>l</strong>, <strong>h</strong> и <strong>L</strong> игнорируются. Целые
	    числа преобразуются так, как будто никакого модификатора
	    не было задано, а действительные числа - как при
	    модификаторе <strong>l</strong>, то есть с использованием типа
	    <strong>double</strong> для внутреннего представления.</td>
	</tr>
    </table>
  </body>
</html>
