<HTML><HEAD>
<BASEFONT FACE="Times New Roman" SIZE="2" COLOR="#000000">
</HEAD>
<BODY>
<div><H3><b>puts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Commandes Internes Tcl</b></H3></div>
<HR ALIGN="center">

<div><b>NOM</b></div><br>
<div ALIGN="LEFT" style="margin-left: 51px;">puts - Ecrit dans un canal 
</div><br>
<div><b>SYNTAXE</b></div><br>
<div ALIGN="LEFT" style="margin-left: 51px;"><b>puts </b>?<b>-nonewline</b>? ?<i>channelId</i>? <i>string</i>
</div><br>
<div><b>DESCRIPTION</b></div><br>
<div ALIGN="LEFT" style="margin-left: 51px;">Ecrit les caractères donnés par <i>string</i> dans le canal donné par <i>channelId</i>. <i>ChannelId</i> doit être un identificateur de canal tel que celui renvoyé par un précédent appel de <A HREF="142.htm"><b>open</b></A> ou <A HREF="162.htm"><b>socket</b></A>. It doit avoir été ouvert pour une sortie. Si aucun <i>channelId</i> n'est spécifié alors il est par defaut de <b>stdout</b>. <b>Puts</b> normalement emet un caractère newline après <i>string</i>, mais cette fonctionnalité peut être supprimé en specifiant le switch<b> -</b> <b>nonewline</b>. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">Les caractères newline dans la sortie sont traduits par <b>puts</b> en séquences fin de ligne spécifique à la plate-forme en accord avec la valeur courante de l'option <b>-translation</b> pour le canal (par exemple, sur les PCs les saut de lignes sont normalement remplacé avec carriage-return-linefeed séquences;&nbsp; sur Macintosh les saut de lignes sont normalement remplacé avec carriage- return). Voir la page de manuel <A HREF="109.htm"><b>fconfigure</b></A> pour une discussion sur la manière dans laquelle <A HREF="109.htm"><b>fconfigure</b></A> modifie la sortie. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">Tcl met la sortie en tampon en interne, donc les caractères écrits avec <b>puts</b> peuvent ne pas apparaitre immédiatement sur le fichier ou périphérique de sortie;&nbsp; Tcl retarde normalement la sortie jusqu'a ce que le tampon soit plein ou le canal fermé. Vous pouvez forcer la sortie à apparaitre immédiatement avec la commande<A HREF="114.htm"><b> flush</b></A>. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">Quand le tampon de sortie est plein, la commande <b>puts</b> bloquera&nbsp; normalement jusqu'a ce que toutes les données en tampon aient été acceptées pour sortie par le système d'exploitation. Si <i>channelId</i> est en mode non bloquant alors la commande <b>puts</b> ne bloquera pas même si le système d'exploitation ne peut pas accepter&nbsp; les données. Par contre, Tcl continue à mettre les données en tampon et les écrit en arrière-plan aussi vite que le sous-jacent fichier ou périphérique peut les accepter. L'application doit utiliser la boucle d'évènement Tcl pour que la sortie non bloquante fonctionne; autrement Tcl ne voit jamais que le fichier ou le périphérique est prèt à sortir plus de données. Il est possible pour une arbitrairement large quantité de données d'être en tampon pour un canal en mode non bloquant, ce qui peut consommer une large quantité de mémoire. Pour éviter de gaspiller la mémoire, les I/O nonbloquantes doivent normalement être utilisées d'une façon pilotée par évènement avec la commande <A HREF="112.htm"><b>fileevent</b></A> (n'appellez pas <b>puts</b> à moins que vous ayez recemment notifié via un évènement fichier que le canal est prèt à afficher plus de données).
</div><br>
<div><b>VOIR EGALEMENT</b></div><br>
<div ALIGN="LEFT" style="margin-left: 51px;"><A HREF="112.htm">fileevent</A>(n)</div><br>
<div>Dernière révision: 7.5</div>
<br>
<br><div ALIGN="CENTER"><A HREF="index.htm"><b>Index</b></A>&nbsp;&nbsp;<A HREF="147.htm"><b>Précédent</b></A>&nbsp;&nbsp;<A HREF="149.htm"><b>Suivant</b></A></div>
</BODY></HTML>
