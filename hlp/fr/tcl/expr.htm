<HTML><HEAD>
<BASEFONT FACE="Times New Roman" SIZE="2" COLOR="#000000"> 
</HEAD>
<BODY>
<div><H3><b>expr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Commandes Internes Tcl</b></H3></div>
<HR ALIGN="center">

<div><b>NOM</b></div><br>
<div ALIGN="LEFT" style="margin-left: 51px;">expr - Evalue une expression 
</div><br>
<div><b>SYNTAXE</b></div><br>
<div ALIGN="LEFT" style="margin-left: 51px;"><b>expr </b><i>arg </i>?<i>arg arg ...</i>? 
</div><br>
<div><b>DESCRIPTION</b></div><br>
<div ALIGN="LEFT" style="margin-left: 51px;">Concatène <i>arg</i>'s (en y ajoutant des séparateurs espaces), évalue le résultat comme expression Tcl, et retourne la valeur. Les opérateurs autorisés dans les expressions Tcl sont un sous ensemble des opérateurs autorisés dans les expressions C, et ils ont les même sens et précédence que les opérateurs C correspondants. Les expressions donnent presque toujours des résultats numériques (entier ou valeurs flottantes). Par exemple, l'expression </div>
<div ALIGN="LEFT" style="margin-left: 102px;"><b>expr 8.2 + 6</b></div>
<div ALIGN="LEFT" style="margin-left: 51px;">est évaluée à 14.2. Les expressions Tcl diffèrent des expressions C dans le sens ou les opérandes sont spécifiés. De plus, les expressions Tcl supportent les opérandes non-numériques et les comparaisons de chaînes. 
</div><br>
<div><b>OPERANDES</b></div><br>
<div ALIGN="LEFT" style="margin-left: 51px;">Une expression Tcl consiste en une combinaison d'opérandes, d'opérateurs, et de parenthèses. L'espace peut être employé entre les opérandes, opérateurs et parenthèses; il est ignoré par les instructions d'expression. Si possible, les opérandes sont interprétés comme des valeurs entières. Les valeurs entières peuvent être spécifiées en décimal (le cas normal), en octal (si le premier caractère de l'opérande est <b>0</b>), ou en hexadécimal (si les deux premiers caractères de l'opérande sont <b>0x</b>). Si un opérande n'est pas un des formats entiers donnés plus haut, alors il est traité comme un nombre flottant si c'est possible. Les nombres flottants peuvent être spécifiés de toutes les manières acceptées par un compilateur compatible ANSI-C (excepté que les suffixes<b> f</b>, <b>F</b>, <b>l</b>, et <b>L</b> ne seront pas autorisés dans la plupart des installations). Par exemple, tous les nombres flottants suivants sont valides : 2.1, 3., 6e4, 7.91e+16. Si aucune interprétation numérique n'est possible, alors un opérande est considéré comme une chaîne (et seulement un ensemble limité d'opérateurs peut lui être appliqué). </div>
<div ALIGN="LEFT" style="margin-left: 51px;">Les opérandes peuvent être spécifiés d'une des façons suivantes: </div>
<div ALIGN="LEFT" style="margin-left: 51px;">&#91;1]&nbsp;&nbsp;&nbsp;&nbsp;Comme une valeur numérique, soit entière soit flottante. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">&#91;2]&nbsp;&nbsp;&nbsp;&nbsp;Comme une variable Tcl, en utilisant la notation standard <b>&#36;</b>. La valeur de la variable sera utilisée comme opérande. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">&#91;3]&nbsp;&nbsp;&nbsp;&nbsp;Comme une chaîne entourée de doubles-guillemets. L'analyseur d'expression effectuera les substitution de backslash, de variable, et de commandes sur l'information entre guillemets, et utilisera la valeur résultante comme opérande </div>
<div ALIGN="LEFT" style="margin-left: 51px;">&#91;4]&nbsp;&nbsp;&nbsp;&nbsp;Comme une chaîne entourée d'accolades. Les caractères entre l'accolade ouverte et l'accolade fermante correspondante seront utilisés comme opérande sans aucunes substitutions. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">&#91;5]&nbsp;&nbsp;&nbsp;&nbsp;Comme une commande Tcl entourée de crochets. La commande sera exécutée et son résultat sera utilisé comme opérande. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">&#91;6]&nbsp;&nbsp;&nbsp;&nbsp;Comme une fonction mathématique dont les arguments ont une des formes definies plus haut pour les opérandes , tel que <b>sin(&#36;x)</b>. Voir ci-dessous pour une liste de fonctions définies. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">Ou les substitutions se produisent plus haut (ex. dans les chaînes entre guillemets), elles sont effectuées par les instructions des expressions. Néanmoins, une couche de substitution supplémentaire peut déjà avoir été effectuée par l'analyseur de commande avant que le processeur d'expression ait été appelé. Comme expliqué ci-dessous, il est préférable d'entourer les expressions dans des accolades pour empêcher l'analyseur de commande d'effectuer des substitutions sur le contenu. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">Pour quelques exemples d'expressions simples, supposez que la variable <b>a</b> a pour valeur 3 et la variable <b>b</b> a pour valeur 6. </div>
<div ALIGN="LEFT" style="margin-left: 102px;"><b>expr 3.1 + &#36;a6.1<br>
</b><b>expr 2 + &quot;&#36;a.&#36;b&quot;5.6<br>
</b><b>expr 4*&#91;llength &quot;6 2&quot;]8<br>
</b><b>expr &#123;&#123;word one} &lt; &quot;word &#36;a&quot;}0</b><br>
</div><br>
<div><b>OPERATEURS</b></div><br>
<div ALIGN="LEFT" style="margin-left: 51px;">Les opérateurs valides sont listés ci-dessous, groupés en ordre de précédence décroissant: 
<DL>
  <DT><b>- + ~ !</b><br></DT><DD>Moins unaire, plus unaire, NOT bit à bit, NOT logique. Aucun de ces opérateurs ne peut être appliqué aux opérandes chaîne, et NOT bit à bit peut seulement être appliqué aux entiers. 
</DD>
  <DT><b>* / %</b><br></DT><DD>Multiplication, division, modulo. Aucun de ces opérandes ne peut être appliqué aux opérandes chaîne, et modulo peut être appliqué seulement aux entiers. modulo Modulo aura toujours le même signe que le diviseur et une valeur absolue inférieure au diviseur. 
</DD>
  <DT><b>+ -</b><br></DT><DD>Addition et soustraction. Valides pour tout opérande numérique. 
</DD>
  <DT><b>&lt;&lt; &gt;&gt;</b><br></DT><DD>Décalage à gauche et à droite. Valides seulement pour les opérandes entiers. Un décalage à droite propage toujours le bit de signe. 
</DD>
  <DT><b>&lt; &gt; &lt;= &gt;=</b><br></DT><DD>Booléens inférieur à, supérieur à, inférieur à ou égal, et supérieur à ou égal. Chaque opérateur donne 1 si la condition est vraie, 0 autrement. Ces opérateurs peuvent être appliqués aux chaînes aussi bien qu'aux opérandes numériques, dans le cas des chaînes, une comparaison est utilisée. 
</DD>
  <DT><b>== !=</b><br></DT><DD>Booléen égal et différent. Chaque opérateur produit un zéro/un résultat. Valides pour tout types d'opérande. 
</DD>
  <DT><b>&amp;</b><br></DT><DD>ET Bit à bit. Valide pour des opérandes entiers seulement. 
</DD>
  <DT><b>^</b><br></DT><DD>OU exclusif Bit à bit. Valide pour des opérandes entiers seulement. 
</DD>
  <DT><b>|</b><br></DT><DD>OU Bit à bit. Valide pour des opérandes entiers seulement. </DD>
  <DT><b>&amp;&amp;</b><br></DT><DD>ET logique. Donne 1 si les deux opérandes sont différent de zéro, 0 autrement. Valide seulement pour pour les opérandes booléens et numériques (entiers ou flottants). 
</DD>
  <DT><b>||</b><br></DT><DD>OU logique. Donne 0 si les deux opérandes sont zéro, 1 autrement. Valide seulement pour opérandes booléens et numériques (entiers ou flottants). 
</DD>
  <DT><i>x</i><b>?</b><i>y</i><b>:</b><i>z</i><br></DT><DD>If-then-else, comme en C. Si <i>x</i> est évalué différent de zéro, alors le résultat est la valeur de <i>y</i>. Autrement le résultat est la valeur de <i>z</i>. L'opérande <i>x</i> doit avoir une valeur numérique. 
</DD>
</DL>
</div>
<div ALIGN="LEFT" style="margin-left: 51px;">Voir le manuel C pour plus de détails sur les résultats produits par chaque opérateur. Tous les opérateurs binaire sont groupés de gauche à droite à l'intérieur d'un même niveau de précédence. Par exemple, la commande </div>
<div ALIGN="LEFT" style="margin-left: 102px;"><b>expr 4*2 &lt; 7</b></div>
<div ALIGN="LEFT" style="margin-left: 51px;">retourne 0. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">Les opérateurs <b>&amp;&amp;</b>, <b>||</b>, et <b>?:</b> ont une &quot;évaluation paresseuse&quot;, juste comme en C, ce qui signifie que ces opérandes ne ont pas évalués s'ils ne sont pas nécessaires pour déterminer le résultat. Par exemple, dans la commande </div>
<div ALIGN="LEFT" style="margin-left: 102px;"><b>expr &#123;&#36;v ? &#91;a] : &#91;b]}</b></div>
<div ALIGN="LEFT" style="margin-left: 51px;">seulement un des <b>&#91;a]</b> ou <b>&#91;b]</b> sera évalué, dépendant de la valeur de <b>&#36;v</b>. Notez, néanmoins, que ceci est seulement vrai si l'expression entière est entourée d'accolades; autrement l'analyseur Tcl evaluera <b>&#91;a]</b> et <b>&#91;b]</b> avant d'appeler la commande<b> expr</b>. 
</div><br>
<div><b>FONCTIONS MATHEMATIQUES </b></div><br>
<div ALIGN="LEFT" style="margin-left: 51px;">Tcl supporte les fonctions mathématiques suivantes dans les expressions: <br>

<TABLE ALIGN="center" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="80%">
  <TR ALIGN="center">
    <TD>
    abs    
    </TD>
    <TD>
    cosh
    </TD>
    <TD>
    log 
    </TD>
    <TD>
    sqrt
    </TD>
  </TR>
  <TR ALIGN="center">
    <TD>
    acos   
    </TD>
    <TD>
    double
    </TD>
    <TD>
    log10
    </TD>
    <TD>
    srand
    </TD>
  </TR>
  <TR ALIGN="center">
    <TD>
    asin   
    </TD>
    <TD>
    exp
    </TD>
    <TD>
    pow
    </TD>
    <TD>
    tan
    </TD>
  </TR>
  <TR ALIGN="center">
    <TD>
    atan  
    </TD>
    <TD>
    floor
    </TD>
    <TD>
    rand
    </TD>
    <TD>
    tanh
    </TD>
  </TR>
  <TR ALIGN="center">
    <TD>
    atan2  
    </TD>
    <TD>
    fmod 
    </TD>
    <TD>
    round
    </TD>
    <TD>
    <!--R5C4-->
    </TD>
  </TR>
  <TR ALIGN="center">
    <TD>
    ceil   
    </TD>
    <TD>
   hypot
    </TD>
    <TD>
    sin
    </TD>
    <TD>
    <!--R6C4-->
    </TD>
  </TR>
  <TR ALIGN="center">
    <TD>
    cos  
    </TD>
    <TD>
    int
    </TD>
    <TD>
    sinh</b >
    </TD>
    <TD>
    <!--R7C4-->
    </TD>
  </TR>
</TABLE><br>
<DL>
  <DT><b>abs(</b><i>arg</i><b>)</b></DT><DD>Renvoie la valeur absolue de <i>arg</i>. <i>Arg</i> peut être entier ou flottant, et le résultat renvoyé est de la même forme.
</DD>
  <DT><b>acos(</b><i>arg</i><b>)</b></DT><DD>Renvoie l'arc cosinus de <i>arg</i>, dans l'intervalle &#91;0,pi] radians. <i>Arg</i> sera dans l'intervalle &#91;-1,1]. 
</DD>
  <DT><b>asin(</b><i>arg</i><b>)</b></DT><DD>Renvoie l'arc sinus de <i>arg</i>, dans l'intervalle &#91;-pi/2,pi/2] radians. <i>Arg</i> sera dans l'intervalle &#91;-1,1]. 
</DD>
  <DT><b>atan(</b><i>arg</i><b>)</b></DT><DD>Renvoie l'arc tangente de <i>arg</i>, dans l'intervalle &#91;-pi/2,pi/2] radians. 
</DD>
  <DT><b>atan2(</b><i>x, y</i><b>)</b></DT><DD>Renvoie l'arc tangente de <i>y</i>/<i>x</i>, dans l'intervalle &#91;-pi,pi] radians. <i>x</i> et <i>y</i> ne peuvent êtretous les deux 0. 
</DD>
  <DT><b>ceil(</b><i>arg</i><b>)</b></DT><DD>Renvoie la plus petite valeur entière non inférieure à <i>arg</i>.
</DD>
  <DT><b>cos(</b><i>arg</i><b>)</b></DT><DD>Renvoie le cosinus de <i>arg</i>, mesuré en radians. 
</DD>
  <DT><b>cosh(</b><i>arg</i><b>)</b></DT><DD>Renvoie le cosinus hyperbolique de <i>arg</i>. Si le résultat cause un débordement, une erreur est renvoyée.
</DD>
  <DT><b>double(</b><i>arg</i><b>)</b></DT><DD>Si <i>arg</i> est une valeur flottante , retourne <i>arg</i>, autrement convertit <i>arg</i> en flottant et retourne la valeur convertie. 
</DD>
  <DT><b>exp(</b><i>arg</i><b>)</b></DT><DD>Renvoie l'exponentiel de <i>arg</i>, défini comme e**<i>arg</i>. Si le résultat cause un débordement, une erreur est renvoyée. 
</DD>
  <DT><b>floor(</b><i>arg</i><b>)</b></DT><DD>Renvoie la plus grande valeur entière non supérieure à <i>arg</i>.</DD>
  <DT><b>fmod(</b><i>x, y</i><b>)</b></DT><DD>Renvoie le reste flottant de la division of <i>x</i> par <i>y</i>. Si <i>y</i> est 0, une erreur est renvoyée. 
</DD>
  <DT><b>hypot(</b><i>x, y</i><b>)</b></DT><DD>Calcule la longueur de l'hypoténuse d'un triangle rectangle(<i>x</i>*<i>x</i>+<i>y</i>*<i>y</i>). 
</DD>
  <DT><b>int(</b><i>arg</i><b>)</b></DT><DD>Si <i>arg</i> est une valeur entière, retourne <i>arg</i>, autrement convertit <i>arg</i> en entier par truncature et retourne la valeur convertie. 
</DD>
  <DT><b>log(</b><i>arg</i><b>)</b></DT><DD>Renvoie le logarithme naturel de <i>arg</i>. <i>Arg</i> doit être une valeur positive. 
</DD>
  <DT><b>log10(</b><i>arg</i><b>)</b></DT><DD>Renvoie le logarithme base 10 de <i>arg</i>. <i>Arg</i> doit être une valeur positive. 
</DD>
  <DT><b>pow(</b><i>x, y</i><b>)</b></DT><DD>Calcule la valeur de <i>x</i> elevé à la puissance <i>y</i>. Si <i>x</i> est négatif, <i>y</i> doit être une valeur entière.
</DD>
  <DT><b>rand()</b></DT><DD>Renvoie un nombre flottant compris entre zéro et juste inférieur à un ou, en termes mathématiques, l'intervalle &#91;0,1]. La graine vient de l'horloge interne de la machine ou peut être fixée manuelllement avec la fonction <b>srand</b>. 
</DD>
  <DT><b>round(</b><i>arg</i><b>)</b></DT><DD>Si <i>arg</i> est une valeur entière, retourne <i>arg</i>, autrement convertit <i>arg</i> en entier arrondi et retourne la valeur convertie. 
</DD>
  <DT><b>sin(</b><i>arg</i><b>)</b></DT><DD>Renvoie le sinus de <i>arg</i>, mesuré en radians.
</DD>
  <DT><b>sinh(</b><i>arg</i><b>)</b></DT><DD>Renvoie le sinus hyperbolique de <i>arg</i>. Si résultat cause un débordement, une erreur est renvoyée. 
</DD>
  <DT><b>sqrt(</b><i>arg</i><b>)</b></DT><DD>Renvoie la racine carrée de <i>arg</i>. <i>Arg</i> doit être non-négatif. 
</DD>
  <DT><b>srand(</b><i>arg</i><b>)</b></DT><DD>Le <i>arg</i>, qui doit être un entier, est utilisé pour réinitialiser la graine du generateur de nombre aléatoire. Renvoie le premier nombre aléatoire de cette graine. Chaque interpréteur a sa propre graine. 
</DD>
  <DT><b>tan(</b><i>arg</i><b>)</b></DT><DD>Renvoie la tangente de <i>arg</i>, mesurée en radians. 
</DD>
  <DT><b>tanh(</b><i>arg</i><b>)</b></DT><DD>Renvoie la tangente hyperbolique de <i>arg</i>. </DD>
</DL>
</div>
<div ALIGN="LEFT" style="margin-left: 51px;">En plus de ces fonctions prédéfinies, les applications peuvent definir des fonctions additionelles en utilisant <A HREF="22.htm"><b>Tcl_CreateMathFunc</b></A>(). 
</div><br>
<div><b>TYPES, DEBORDEMENT, ET PRECISION</b></div><br>
<div ALIGN="LEFT" style="margin-left: 51px;">Tous les calculs internes impliquant des entiers sont fait avec le type C <i>long</i>, et tous calculs internes impliquant des flottants sont fait avec le type C <i>double</i>. Pendant la conversion d'une chaîne en valeur flottante, le débordement d'exposant est détecté et donne une erreur Tcl. Pour la conversion d'une chaîne en entier, la detection du débordement depend du comportement de quelques routines dans la bibliothèque C locale, donc il doit être considéré comme non fiable. Dans tous les cas, le débordement entier n'est généralement pas détecté avec fiabilité dans les résultats intermédiaires. Le débordement flottant est détecté par le matériel, qui est généralement fiable. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">La conversion dans les representations internes des opérandes entiers, flottants, et chaînes est faite automatiquement si besoin. Pour les calculs arithmétiques, les entiers sont utilisés jusqu'a ce qu'un nombre flottant soit introduit, après lequel les flottants sont utilisés. Par exemple, </div>
<div ALIGN="LEFT" style="margin-left: 102px;"><b>expr 5 / 4</b></div>
<div ALIGN="LEFT" style="margin-left: 51px;">renvoie 1, alors que </div>
<div ALIGN="LEFT" style="margin-left: 102px;"><b>expr 5 / 4.0</b><br>
<b>expr 5 / ( &#91;string length &quot;abcd&quot;] + 0.0 )</b></div>
<div ALIGN="LEFT" style="margin-left: 51px;">renvoient 1.25. Les valeurs flottantes sont toujours renvoyées avec un &quot;<b>.</b>&quot; ou un <b>e</b> ainsi elles ne ressemblent pas aux valeur entières. Par exemple, </div>
<div ALIGN="LEFT" style="margin-left: 102px;"><b>expr 20.0/5.0</b></div>
<div ALIGN="LEFT" style="margin-left: 51px;">retourne <b>4.0</b>, pas <b>4</b>. 
</div><br>
<div><b>OPERATIONS SUR DES CHAINES </b></div><br>
<div ALIGN="LEFT" style="margin-left: 51px;">Les valeurs chaîne peuvent être employées comme opérandes des opérateurs de comparaison, bien que l'evaluateur d'expression essaye de comparer si possible des entiers ou des flottants. Si un des opérandes d'une comparaison est une chaîne et que l'autre a une valeur numérique, l'opérande numérique est converti en une chaîne en utilisant le spécificateur de format C <i>sprintf</i> <b>%d</b> pour les entiers et <b>%g</b> pour les valeurs flottantes. Par exemple, les commandes </div>
<div ALIGN="LEFT" style="margin-left: 102px;"><b>expr &#123;&quot;0x03&quot; &gt; &quot;2&quot;}</b><br>
<b>expr &#123;&quot;0y&quot; &lt; &quot;0x12&quot;}</b></div>
<div ALIGN="LEFT" style="margin-left: 51px;">renvoient toutes les deux 1. La première comparaison est faite en utilisant la comparaison entière, et la seconde est faite en utilisant la comparaison de chaînes après que le second opérande ait été converti en la chaîne <b>18</b>. parce que Tcl a tendance a traiter les valeurs comme des nombres chaque fois que possible, ce n'est généralement pas une bonne idée d'utiliser des operateurs comme <b>==</b> quand vous desirez une comparaison de chaînes et les valeurs des opérandes pourraient être arbitraires; il est préférable dans ces cas d'utiliser la commande <A HREF="165.htm"><b>string</b></A> . 
</div><br>
<div><b>CONSIDERATIONS DE PERFORMANCE </b></div><br>
<div ALIGN="LEFT" style="margin-left: 51px;">Entourez les expressions d'accolades pour la rapidité et le stockage le moins encombrant. Ceci permet au compilateur bytecode Tcl de générer le meilleur code. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">Comme mentionné plus haut, les expressions sont substituées deux fois: une fois par l'analyseur Tcl et une fois par la commande<b> expr</b>. Par exemple, les commandes </div>
<div ALIGN="LEFT" style="margin-left: 102px;"><b>set a 3</b><br>
<b>set b &#123;&#36;a + 2}</b><br>
<b>expr &#36;b*4</b></div>
<div ALIGN="LEFT" style="margin-left: 51px;">retourne 11, pas un multiple de 4. Ceci parce que l'analyseur Tcl substituera en premier <b>&#36;a + 2</b> pour la variable <b>b</b>, ensuite la commande <b>expr</b> evaluera l'expression <b>&#36;a + 2*4</b>. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">La plupart des expressions n'exigent pas une seconde passe de substitutions. Soit elles sont entourées d'accolades ou, sinon, leurs substitutions de variable et de commandes donnent des nombres ou des chaînes qui eux-même n'exigent pas de substitutions. Néanmoins, parce que quelques expressions non entourées d'accolades nécéssitent deux passes de substitutions, le compilateur bytecode doit emettre des instructions supplémentaires pour gérer cette situation. Le code le plus couteux est requis pour les expressions non entourées d'accolades qui contiennent des substitutions de commandes. Ces expressions doivent être implémentées par la génération de nouveau code chaque fois que l'expression est exécutée. </div><br>
<div>Dernière révision: 8.3</div>
<br>
<br><div ALIGN="CENTER"><A HREF="index.htm"><b>Index</b></A>&nbsp;&nbsp;<A HREF="106.htm"><b>Précédent</b></A>&nbsp;&nbsp;<A HREF="108.htm"><b>Suivant</b></A>
</div>
</BODY></HTML>
 
