<HTML><HEAD>
<BASEFONT FACE="Times New Roman" SIZE="2" COLOR="#000000">
</HEAD>
<BODY>
<div><H3><b>interp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Commandes Internes Tcl</b></H3></div>
<HR ALIGN="center">
<div><b>NOM</b></div> <br>
<div ALIGN="LEFT" style="margin-left: 51px;">interp - Crée et manipule des interpréteurs Tcl
</div> <br>
<div><b>SYNTAXE</b></div> <br>
<div ALIGN="LEFT" style="margin-left: 51px;"><b>interp </b><i>option </i>?<i>arg arg ...</i>?&nbsp; 
</div><br>
<div><b>DESCRIPTION</b></div> <br>
<div ALIGN="LEFT" style="margin-left: 51px;">Cette commande permet la création d'un ou plusieurs nouveaux interpréteurs Tcl qui coexistent avec l'interpréteur créateur dans la même application. L'interpréteur créateur est appelé le <i>maître</i> et le nouvel interpréteur est appelé l'<i>esclave</i>. Un maître peut créer n'importe quel nombre d'esclaves, et chaque esclave peut lui-même créer des esclaves supplémentaires pour lequel il est maître, créant ainsi une hiérarchie d'interpréteurs. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">Chaque interpréteur est indépendant des autres: il a son propre namespace pour les commandes, fonctions, et variables globales. Un maître interpréteur peut créer des connections entre ses esclaves et lui-même en utilisant un mécanisme appelé un <i>alias</i> Un <i>alias</i> est une commande dans un interpréteur esclave qui, quand elle est appelée, provoque l'appel d'une commande dans son interpréteur maître ou dans un autre interpréteur esclave Les seules autres connections entre interpréteurs sont au travers de variable d'environnements (la variable<b> env</b>), qui sont normalement partagées entre tous les interpréteurs dans l'application. Notez que le namespace pour les fichiers (tel que les noms renvoyé par la commande<A HREF="142.htm"><b> open</b></A>) n'est pas partagé entre interpréteurs. Des commandes explicites sont fournies pour partager les fichiers et transférer les références à un fichier ouvert d'un interpréteur à un autre. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">La commande <b>interp</b> fournit aussi le support des interpréteurs<i> safe</i> Un interpréteur sùr est un esclave dont les fonctions ont été grandement restreintes, ainsi il est plus sùr d'exécuter un script étranger sans risque pour les autres interpréteurs ou l'environnement d'application. Par exemple, toutes commandes de création de canal IO et les commandes de création de sous-process sont rendues inaccessible aux interpréteurs sùrs. Voir INTERPRETEURS SURS ci-dessous pour plus d'information sur les fonctionnalités présentes dans un interpréteur sùr. Les fonctionalités dangereuses ne sont pas enlevées de l'interpréteur sùr; par contre, elle sont <i>cachées</i>, ainsi seul les interpréteurs de confiance peuvent y acceder. Pour une explication détaillée des commandes cachées, voir COMMANDES CACHEES, ci-dessous. Le mécanisme d'alias peut être utilisé pour une communication protégée (analogue à un appel kernel) entre un interpréteur esclave et son maître. Voir INVOCATION D'ALIAS, ci-dessous, pour plus de détails sur comment le mécanisme d'alias fonctionne. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">Un nom d'interpréteur qualifié est une liste Tcl correcte contenant une sous ensemble de ses ancêtres dans la hiérarchie de l'interpréteur, terminée par les chaîne désignant l'interpréteur dans son maître immédiat. Les noms d'interpréteur sont relatif à l'interpréteur dans lequel ils sont utilisés. Par exemple, si <b>a</b> est un esclave de l'interpréteur courant et qu'il a un esclave <b>a1</b>, qui à son tour a un esclave <b>a11</b>, le nom qualifié de <b>a11</b> dans <b>a</b> est la liste <b>a1 a11</b>. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">La commande<b> interp</b>, décrite ci-dessous, accepte des noms d'interpréteur qualifiés comme arguments; l'interpréteur dans lequel la commande est évaluée peut toujours être référencé comme <b>&#123;}</b> (la liste ou chaîne vide). Notez qu'il est impossible de se referer&nbsp; à un maître (ancestor) interpréteur par son nom dans un interpréteur esclave excepté au travers d'alias. Egalement, il n'y a pas de nom global par lequel se referer&nbsp; au premier interpréteur créé dans une application. L'ensemble de ces restrictions sont motivées par des raisons de sécurité <br>
</div> <br>
<div><b>LA COMMANDE INTERP </b></div> <br>
<div ALIGN="LEFT" style="margin-left: 51px;">La commande <b>interp</b> est utilisée pour créer, effacer, et manipuler des interpréteurs esclaves, et pour partager ou transferer des canaux entre interpréteurs Elle peut avoir une parmi plusieurs formes, dépendantes de l'argument<i> option</i>: 
<DL>
  <DT><br><b>interp</b> <b>alias</b> <i>srcPath</i> <i>srcCmd</i>
</DT><DD>Renvoie une liste Tcl dont les éléments sont les <i>targetCmd</i> et <i>arg</i>s associés à l'alias nommé <i>srcCmd</i> (ce sont toutes les valeurs spécifiées quand l'alias a été créé; il est possible que la commande source actuelle dans l'esclave soit différente de <i>srcCmd</i> si elle a été renommée). 
</DD>
  <DT><br><b>interp</b> <b>alias</b> <i>srcPath</i> <i>srcCmd</i> <b>&#123;}</b>
</DT><DD>Efface l'alias de <i>srcCmd</i> dans l'interpréteur esclave identifié par <i>srcPath</i>. <i>srcCmd</i> se réfère au nom sous lequel l'alias a été créé si la commande source a été renommée, la commande renommée sera effacée. 
</DD>
  <DT><br><b>interp</b> <b>alias</b> <i>srcPath</i> <i>srcCmd</i> <i>targetPath</i> <i>targetCmd </i>?<i>arg arg ...</i>?
</DT><DD>Cette commande crée un alias entre un esclave et un autre (voyez la commande <b>alias</b> esclave ci-dessous pour la création d'alias entre un esclave et son maître) Dans cette commande, chacun des interpréteurs esclave peut être n'importe où dans la hiérarchie des interpréteurs sous l'interpréteur qui appelle la commande. <i>SrcPath</i> et <i>srcCmd</i> identifient le source de l'alias. <i>SrcPath</i> est une liste Tcl dont les éléments désignent un interpréteur particulier Par exemple, &quot;<b>a b</b>&quot; identifie un interpréteur <b>b</b>, qui est une esclave de l'interpréteur <b>a</b>, qui est un esclave de l'interpréteur appelant Une liste vide spécifie l'interpréteur appelant la commande <i>srcCmd</i> donne le nom d'une nouvelle commande, qui sera créée dans l'interpréteur source. <i>TargetPath</i> et <i>targetCmd</i> spécifient une cible interpréteur et commande, et l'arguments<i> arg</i>, s'il existe, Spécifie les arguments supplémentaires à <i>targetCmd</i> qui sont ajoutés à tout argument spécifié dans l'appel de <i>srcCmd</i>. <i>TargetCmd</i> peut être indéfini à l'instant de cet appel, ou il peut existe déjàr; il n'est pas créé par cette commande. L'alias prépare la commande cible à être appelée&nbsp; dans l'interpréteur cible chaque fois que la commande source est appelée dans l'interpréteur source Voir APPEL D'ALIAS ci-dessous pour plus de détails. 
</DD>
  <DT><br><b>interp</b> <b>aliases </b>?<i>path</i>?
</DT><DD>Cette commande retourne une liste Tcl de noms de toutes les commandes source des alias définis dans l'interpréteur identifié par <i>path</i>. 
<b>interp</b> <b>create </b>?<b>-safe</b>? ?<b>--</b>? ?<i>path</i>?<br>
Crée un interpréteur esclave identifié par <i>path</i> et une nouvelle commande, appelé une <i>slave command</i>. Le nom de la commande esclave est le dernier composant de <i>path</i>. Le nouvel interpréteur esclave et la commande esclave sont créée dans l'interpréteur identifié par le chemin obtenu en enlevant le dernier composant de <i>path</i>. Par exemple, si <i>path </i>est<i> </i><b>a bc</b> alors un nouvel interpréteur et commande esclave nommés <b>c</b> sont créés dans l'interpréteur identifié par les chemin <b>a b</b>. La commande esclave peut être employée pour manipuler le nouvel interpréteur comme décrit ci-dessous. Si <i>path</i> est omis, Tcl crée un nom unique de la forme <b>interp</b><i>x</i>, où <i>x</i> est un entier, et l'utilise pour l'interpréteur et la commande esclave. Si le switch <b>-safe</b> est spécifié (ou si le maître interpréteur est un interpréteur sùr), le nouvel interpréteur esclave sera créé comme un interpréteur sùr avec des fonctionalité limitées; autrement l'esclave inclutra le jeu complet des commandes et variables Tcl internes. Le <b>--</b> switch peut être utilisé pour marquer la fin des commutateurs;&nbsp; il peut être nécessaires si <i>path</i> est une valeur inhabituelle telle que <b>-safe</b>. Le résultat de la commande est le nom du nouvel interpréteur. Le nom d'un interpréteur esclave doit être unique parmi tout les esclaves; une erreur se produit si le nom d'un interpréteur esclave existe déjà pour ce maître. 
</DD>
  <DT><br><b>interp</b> <b>delete </b>?<i>path ...?</i>
</DT><DD>Efface zéro ou plus interpréteurs donnés par les arguments optionnels <i>path</i>, et pour chaque interpréteur, efface aussi ses esclaves. La commande efface aussi la commande esclave de chaque interpréteur effacé. Pour chaque argument<i> path</i>, si aucun interpréteur de ce nom existe, la commande lève une erreur. 
</DD>
  <DT><br><b>interp</b> <b>eval</b> <i>path arg </i>?<i>arg ...</i>?
</DT><DD>Cette commande concatène tous les arguments <i>arg</i> de la même façon que la commande<A HREF="98.htm"><b> concat</b></A>, et évalue alors la chaîne résultante comme script Tcl dans l'interpréteur esclave identifié par <i>path</i>. Le résultat de cette evaluation (incluant l'information d'erreur telle que les variables<b> errorInfo</b> et <b>errorCode</b>, si une erreur se produit) est renvoyé à l'interpréteur appelant . 
</DD>
  <DT><br><b>interp exists </b><i>path</i></DT><DD>Renvoie <b>1</b> si un interpréteur esclave du <i>path</i> spécifié existe dans ce maître, <b>0</b> autrement. Si <i>path</i> est omis, l'interpréteur appelant est utilisé. 
</DD>
  <DT><br><b>interp expose </b><i>path</i> <i>hiddenName</i> ?<i>exposedCmdName</i>?
</DT><DD>Rend la commande cachée <i>hiddenName</i> visible, en lui donnant éventuellement un nouveau nom <i>exposedCmdName</i> (ce nom est couramment accepté seulement si c'est un nom global valide sans quelconque ::), dans l'interpréteur désigné par <i>path</i>. Si une commande visible avec le nom cible existe déjà, cette commande échoue. Les commandes cachées sont expliquées plus en détail dans COMMANDES CACHEES , ci-dessous. 
</DD>
  <DT><br><b>interp</b> <b>hide</b> <i>path</i> <i>exposedCmdName</i> ?<i>hiddenCmdName</i>?
</DT><DD>Cache la commande visible <i>exposedCmdName</i>, en la renommant en commande cachée <i>hiddenCmdName</i>, ou conservant le même nom si <i>hiddenCmdName</i> n'est pas donné, dans l'interpréteur désigné&nbsp; par <i>path</i>. Si une commande cachée avec le nom ciblé existe déjà, cette commande échoue. <i>exposedCmdName</i> et <i>hiddenCmdNamene&nbsp; </i> peuvent&nbsp; pas contenir en même temps de qualificateurs namespace, ou une erreur est levée. Les commandes à cacher par <b>interp hide</b> sont recherchées dans le namespace global&nbsp; même si le namespace&nbsp; courant n'est pas le global. Ceci empêche les esclaves d'abuser un maître interpréteur en cachant les mauvaises commandes, en rendant le namespace courant différent du global. Les commandes cachées sont expliquées plus en détail dans COMMANDES CACHEES , ci-dessous. 
</DD>
  <DT><br><b>interp</b> <b>hidden</b> <i>path</i>
</DT><DD>Renvoie une liste des noms de toutes les commandes cachées dans l'interpréteur identifié par <i>path</i>. 
</DD>
  <DT><br><b>interp</b> <b>invokehidden</b> <i>path</i> ?<b>-global</b>? <i>hiddenCmdName</i> ?<i>arg ...</i>?
</DT><DD>Appelle la commande cachée <i>hiddenCmdName</i> avec les arguments fournis dans l'interpréteur désigné par <i>path</i>. Aucune substitution ou évaluation ne sont appliquées aux arguments. Si le flag <b>-global</b> est présent, la commande cachée est appelée au niveau global dans l'interpréteur cible; autrement elle est appelée dans le cadre d'appel courant et peut acceder aux variables locales dans ce cadre et appeler des cadres externes. Les commandes cachées sont expliquées plus en détail dans COMMANDES CACHEES , ci-dessous. 
</DD>
  <DT><br><b>interp issafe</b> ?<i>path</i>?
</DT><DD>Renvoie <b>1</b> si l'interpréteur identifié par le <i>path</i> spécifié est sùr, <b>0</b> autrement. 
</DD>
  <DT><br><b>interp marktrusted</b> <i>path</i>
</DT><DD>Marque l'interpréteur identifié par <i>path</i> comme fiable. Ne montre pas les commande cachées. Cette commande peut seulement être appelée à partir d'un interpréteur de confiance. La commande n'a pas d'effet si l'interpréteur identifié par <i>path</i> est déjà fiable. 
</DD>
  <DT><br><b>interp</b> <b>share</b> <i>srcPath channelId destPath</i>
</DT><DD>Met en place le partage du canal IO identifié par <i>channelId</i> entre l'interpréteur identifié par <i>srcPath</i> et l'interpréteur identifié par <i>destPath</i>. Les deux interpréteurs ont les même permissions sur le canal IO. Les deux interpréteurs doivent le fermer pour fermer le IO canal sous-jacent; les canaux IO accessibles dans un interpréteur sont automatiquement fermés quand un interpréteur est détruit. 
</DD>
  <DT><br><b>interp</b> <b>slaves</b> ?<i>path</i>?
</DT><DD>Renvoie une liste Tcl des noms de tous les interpréteurs esclaves associés à l'interpréteur identifié par <i>path</i>. Si <i>path</i> est omis, l'interpréteur appelant est utilisé. 
</DD>
  <DT><br><b>interp</b> <b>target</b> <i>path alias</i>
</DT><DD>Renvoie une liste Tcl décrivant l'interpréteur cible d'un alias. L'alias est spécifié avec un chemin d'interpréteur et le nom de la commande source, juste comme dans <b>interp </b><b>alias</b> plus haut. Le nom de&nbsp; l'interpréteur cible est renvoyé comme un chemin d'interpréteur, relatif à l'interpréteur appelant . Si l'interpréteur cible de l'alias est l'interpréteur appelant alors une liste vide est renvoyée. Si l'interpréteur cible de l'alias n'est pas l'interpréteur appelant ou un de ses descendants alors une erreur est générée. La commande cible n'a pas a être définie à l'instant de cet appel. 
</DD>
  <DT><br><b>interp</b> <b>transfer</b> <i>srcPath channelId destPath</i>
</DT><DD>Rends le canal IO identifié par <i>channelId</i> disponible dans l'interpréteur identifié par <i>destPath</i> et indisponible dans l'interpréteur identifié par <i>srcPath</i> 
</DD>
</DL>
</div><br>
<div><b>LA COMMANDE SLAVE </b></div><br>
<div ALIGN="LEFT" style="margin-left: 51px;">Pour chaque interpréteur esclave créé avec lA commande<b> interp</b>, une nouvelle commande Tcl est créée dans le maître interpréteur avec le même nom que le nouvel interpréteur. Cette commande peut être employée pour faire des opérations variées sur l'interpréteur Elle a la forme générale suivante: 
<i>slave command </i>?<i>arg arg ...</i>?</div>
<div ALIGN="LEFT" style="margin-left: 51px;"><i>Slave</i> est le nom de l'interpréteur, et <i>command</i> et <i>arg</i>s determinent le comportement exact de la commande. Les formes valides de cette commande sont: 
<DL>
  <DT><br><i>slave </i><b>aliases</b>
</DT><DD>Renvoie une liste Tcl dont les éléments sont les noms de tous les alias dans <i>slave</i> Les noms renvoyés sont les valeurs <i>srcCmd</i> utilisées quand les alias ont été créés (qui ne peuvent pas être les même que les noms des commandes courantes, si elles ont été renommées). 
</DD>
  <DT><br><i>slave </i><b>alias </b><i>srcCmd</i>
</DT><DD>Renvoie une liste Tcl dont les éléments sont les <i>targetCmd</i> et <i>arg</i>s associés à l'alias nommé <i>srcCmd</i> (toutes sont les valeurs spécifiées quand l'alias a été créée; il est possible que la commande source actuelle dans l'esclave soit différente de <i>srcCmd</i> si elle a été renommée). 
</DD>
  <DT><br><i>slave </i><b>alias </b><i>srcCmd </i><b>&#123;}</b>
</DT><DD>Efface l'alias de <i>srcCmd</i> dans l'interpréteur esclave. <i>srcCmd</i> se réfère au nom sous lequel l'alias a été créé si la commande source a été renommée, la commande renommée sera effacé. 
</DD>
  <DT><br><i>slave </i><b>alias </b><i>srcCmd targetCmd </i>?<i>arg ..</i>?
</DT><DD>Crée un alias tel que chaque fois que <i>srcCmd</i> est appelée dans <i>slave</i>, <i>targetCmd</i> est appelée dans le maître. Les arguments <i>arg</i> seront transmis à <i>targetCmd</i> comme arguments supplémentaires, ajoutés avant tout argument transmis dans l'appel de <i>srcCmd</i>. Voir&nbsp; APPEL D'ALIAS ci-dessous pour les détails. 
</DD>
  <DT><br><i>slave </i><b>eval </b><i>arg </i>?<i>arg ..</i>?</DT><DD>Cette commande concatène tous les arguments <i>arg</i> de la même façon que&nbsp; la commande<A HREF="98.htm"><b> concat</b></A>, et évalue la chaîne résultante comme un script Tcl dans <i>slave</i>. Le résultat de cette évaluation (incluant information erreur telle que les variables<b> </b><b>errorInfo</b> et <b>errorCode</b>, si une erreur se produit) est renvoyé à l'interpréteur appelant . 
</DD>
  <DT><br><i>slave </i><b>expose </b><i>hiddenName </i>?<i>exposedCmdName</i>?
</DT><DD>Cette commande expose la commande cachée<i>hiddenName</i>, lui donnant éventuellement un nouveau nom <i>exposedCmdName</i> (ce nom est couramment accepté seulement si c'est une nom global valide sans quelconque ::), dans <i>slave</i>. Si une commande visible avec le nom ciblé existe déjà, cette commande échoue. Pour plus details sur les commande cachées, voir COMMANDES CACHEES , ci-dessous. 
</DD>
  <DT><br><i>slave </i><b>hide </b><i>exposedCmdName</i> ?<i>hiddenCmdName</i>?
</DT><DD>Cette commande cache la commande visible <i>exposedCmdName</i>, en la renommant en la commande cachée <i>hiddenCmdName</i>, ou gardant le même nom si l'argument n'est pas donné, dans l'interpréteur<i> slave</i>. Si une commande cachée avec le nom ciblé existe déjà, cette commande échoue. Autant <i>exposedCmdName</i> que <i>hiddenCmdName</i> ne peuvent contenir de qualificateurs namespace, ou une erreur est levée. Les commandes a cacher sont recherchée dans le namespace global&nbsp; même si le namespace&nbsp; courant n'est pas le global un . Ceci empêche les esclaves d'abuser un maître interpréteur en cachant les mauvaises commandes, en rendant le namespace courant différent du global. Pour plus details sur les commande cachées, voir COMMANDES CACHEES , ci-dessous. 
</DD>
  <DT><br><i>slave </i><b>hidden</b></DT><DD>Renvoie une liste des noms de toutes les commande cachées dans <i>slave</i>.
<i>slave </i><b>invokehidden</b> ?<b>-global</b> <i>hiddenName </i>?<i>arg ..</i>?<br>
Cette commande appelle la commande cachée <i>hiddenName</i> avec les arguments fournis, dans <i>slave</i>. Aucune substitutions ou évaluations ne sont appliquées aux arguments. Si le flag <b>-global</b> est donné, la commande est appelée au niveau global dans l'esclave; autrement elle est appelée dans le cadre d'appel courant et peut acceder à ses variables locales ou appeler des cadres externes. Pour plus details sur les commande cachées, voir COMMANDES CACHEES , ci-dessous.
</DD>
  <DT><br><i>slave </i><b>issafe</b>
</DT><DD>Renvoie <b>1</b> si l'interpréteur esclave est sùr, <b>0</b> autrement. 
<DT><br><i>slave </i><b>marktrusted</b>
</DT><DD>Marque l'interpréteur esclave comme fiable. Peut seulement être appelée par un interpréteur de confiance. Cette commande ne rend visible aucune commande cachée dans l'interpréteur esclave. La commande n'a pas d'effet si l'esclave est déjà fiable <br>
</DD>
</DL>
</div><br>
<div><b>SAFE INTERPRETERS</b></div><br>
<div ALIGN="LEFT" style="margin-left: 51px;">Un interpréteur sùr a des fonctionalité restreintes, ainsi il est sùr d'exécuter un script arbitraire donné par votre pire ennemi sans s'inquiéter pour l'application hôte ou le reste de votre environnement de travail De manière à rendre un interpréteur sùr, certaines commandes et variables sont enlevése de l'interpréteur. Par exemple, les commandes pour créer fichiers sur disque sont enlevées, et la commande <A HREF="105.htm"><b>exec</b></A> est enlevée, car elle pourrait être utilisée pour faire des dégats à l'aide de sous-processus. Un accès limité à ces facilités peut être fourni, par création d'alias du maître interpréteur pour vérifier leurs arguments soigneusement et fournir un accès restreint à une sous ensemble sùr de facilités. Par exemple, la création de fichier pourra être autorisé dans un sous répertoire particulier et l'appel de sous-processus pourra être autorisé pour un ensemble soigneusement choisi de programmes. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">Un interpréteur sùr est créée en specifiant le switch <b>-safe</b> à la commande<b> interp create</b> Néanmoins, tout esclave créé par un interpréteur sùr sera aussi sùr. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">Un interpréteur sùr est créée avec exactement ce jeu de commandes internes: </div><br>
<b><TABLE ALIGN="center" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="60%">
  <TR>
    <TD>
    after
    </TD>
    <TD>
    append
    </TD>
    <TD>
    array
    </TD>
    <TD>
    binary
    </TD>
  </TR>
  <TR>
    <TD>
    break
    </TD>
    <TD>
    case
    </TD>
    <TD>
    catch
    </TD>
    <TD>
    clock
    </TD>
  </TR>
  <TR>
    <TD>
    close
    </TD>
    <TD>
    concat
    </TD>
    <TD>
    continue
    </TD>
    <TD>
    eof
    </TD>
  </TR>
  <TR>
    <TD>
    error
    </TD>
    <TD>
    eval
    </TD>
    <TD>
    expr
    </TD>
    <TD>
    fblocked
    </TD>
  </TR>
  <TR>
    <TD>
    fcopy
    </TD>
    <TD>
    fileevent
    </TD>
    <TD>
    flush
    </TD>
    <TD>
   for
    </TD>
  </TR>
  <TR>
    <TD>
    foreach
    </TD>
    <TD>
    format
    </TD>
    <TD>
    gets
    </TD>
    <TD>
    global
    </TD>
  </TR>
  <TR>
    <TD>
    history
    </TD>
    <TD>
    if
    </TD>
    <TD>
    incr
    </TD>
    <TD>
    info
    </TD>
  </TR>
  <TR>
    <TD>
    interp
    </TD>
    <TD>
    join
    </TD>
    <TD>
    lappend
    </TD>
    <TD>
   lindex
    </TD>
  </TR>
  <TR>
    <TD>
    linsert
    </TD>
    <TD>
    list
    </TD>
    <TD>
    llength
    </TD>
    <TD>
    lrange
    </TD>
  </TR>
  <TR>
    <TD>
   lreplace
    </TD>
    <TD>
    lsearch
    </TD>
    <TD>
    lsort
    </TD>
    <TD>
    namespace
    </TD>
  </TR>
  <TR>
    <TD>
    package
    </TD>
    <TD>
    pid
    </TD>
    <TD>
    proc
    </TD>
    <TD>
    puts
    </TD>
  </TR>
  <TR>
    <TD>
    read
    </TD>
    <TD>
    regexp
    </TD>
    <TD>
    regsub
    </TD>
    <TD>
    rename
    </TD>
  </TR>
  <TR>
    <TD>
    return
    </TD>
    <TD>
   scan
    </TD>
    <TD>
    seek
    </TD>
    <TD>
    set
    </TD>
  </TR>
  <TR>
    <TD>
    split
    </TD>
    <TD>
    string
    </TD>
    <TD>
    subst
    </TD>
    <TD>
    switch
    </TD>
  </TR>
  <TR>
    <TD>
    tell
    </TD>
    <TD>
    trace
    </TD>
    <TD>
    unset
    </TD>
    <TD>
    update
    </TD>
  </TR>
  <TR>
    <TD>
    uplevel
    </TD>
    <TD>
    upvar
    </TD>
    <TD>
    variable
    </TD>
    <TD>
    vwait
    </TD>
  </TR>
  <TR>
    <TD>
    while
    </TD>
    <TD>
    <!--R17C2-->
    </TD>
    <TD>
    <!--R17C3-->
    </TD>
    <TD>
    <!--R17C4-->
    </TD>
  </TR>
</TABLE></b>

<br>
</div>
<div ALIGN="LEFT" style="margin-left: 51px;">Les commandes suivantes sont cachées par <b>interp create</b> quand il crée un interpréteur sùr: </div><br>
<TABLE ALIGN="center" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="60%">
  <TR>
    <TD>
   cd
    </TD>
    <TD>
   exec
    </TD>
    <TD>
    exit
    </TD>
    <TD>
   fconfigure
    </TD>
  </TR>
  <TR>
    <TD>
    file
    </TD>
    <TD>
    glob
    </TD>
    <TD>
    load
    </TD>
    <TD>
    open
    </TD>
  </TR>
  <TR>
    <TD>
    pwd
    </TD>
    <TD>
    socket
    </TD>
    <TD>
    source
    </TD>
    <TD>
    vwait
    </TD>
  </TR>
</TABLE><br>

<div ALIGN="LEFT" style="margin-left: 51px;">Ces commandes peuvent être recréées plus tard comme fonctions ou alias Tcl, ou réexposées avec <b>interp expose</b>. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">De plus, la variable <b>env</b> n'est pas présente dans un interpréteur sùr, donc il ne peut partager des variables d'environnement avec les autres interpréteurs. La variable <b>env</b> pose un problème de sécurité, parce que les utilisateurs peuvent stocker de l'information sensible dans une variable d'environnement. Par exemple, le manuel PGP recommende de stocker le mot de passe de protection de la clé PGP privée dans la variable d'environnement <i>PGPPASS</i>. Rendre cette variable disponible à l'exécution de code étranger dans un interpréteur sùr induirait une faille de sécurité. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">Si les extensions sont chargées dans un interpréteur sùr, elles peuvent aussi restraindre leur propre fonctionalité pour éliminer les commandes sensibles. Pour une discussion sur la getion des extensions pour la sécurité voyez l 'entrée de manuel des commandes Tcl<A HREF="158.htm"><b> Safe</b></A><b>-</b><A HREF="78.htm"><b>Tcl</b></A> et <A HREF="134.htm"><b>load</b></A> 
</div><br>
<div><b>APPEL D'ALIAS</b></div><br>
<div ALIGN="LEFT" style="margin-left: 51px;">Le mécanisme alias a été soigneusement conçu ainsi il peut être utilisé sùrement quand un script non fiable est exécuté dans un esclave sùr et que le cible de l'alias est une maîtresùr Lachose la plus importante pour garantir la sécurité est de s'assurer qui l'information transmise de l'esclave au maître n'est jamais évaluée ou substituée dans le maître; si ceci se produisait, cela pourrait activer un script de la mort dans l'esclave qui appelerait des fonctions arbitraires dans le maître, pour compromettre la sécurité. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">Quand la source d'un alias est appelée dans l'interpréteur esclave, les substitutions Tcl usuelles sont effectuées à l'analyse de la commande. Ces substitutions sont effectuées dans l'interpréteur source juste comme elles seraient faites pour tout autre commande appelée dans cet interpréteur. La fonction de commande de la commande source prend ses arguments et les mélange avec les <i>targetCmd</i> et <i>arg</i>s de l'alias pour créer un nouveau tableau d'arguments Si les mots de <i>srcCmd</i> etaient &quot;<i>srcCmd arg1 arg2 ... argN</i>&quot;, le nouvel ensemble de mots sera &quot;<i>targetCmd arg arg ... arg arg1 arg2 ... argN</i>&quot;, où <i>targetCmd</i> et <i>arg</i>s sont les valeurs fournies quand l'alias a été créé. <i>TargetCmd</i> est alors utilisée pour localiser une fonction de commande dans l'interpréteur cible, et cette fonction de commande est appelée avec le nouveau jeu d'aguments Un erreur se produit s'il n'y a pas commande nommée <i>targetCmd</i> dans l'interpréteur cible. Aucunes substitutions supplémentaires ne sont effectuées sur les mots, la fonction de commande cible est appelée directement, sans passer au travers du mécanisme evaluation Tcl normal. Les substitutions sont ainsi effectuées sur chaque mot exactement une seule fois: <i>targetCmd</i> et <i>args</i> ont été substituées pendant l'analyse de la commande qui créée l'alias, et <i>arg1 - argN</i> sont substituées quand la commande source de l'alias est analysée dans l'interpréteur source. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">A l'écriture de <i>targetCmd</i>s pour des alias dans des interpréteurs sùrs, il est très important que les arguments de cette commande ne soient jamais évalués ou substitués, car ceci fournirait un mécanisme d'échappement par lequel les interpréteurs esclaves pourraient exécuter du code arbitraire dans le maître Par conséquent, ceci pourrait compromettre la sécurité du système 
</div><br>
<div><b>COMMANDES CACHEES</b></div><br>
<div ALIGN="LEFT" style="margin-left: 51px;">Les interpréteurs sùrs restreignent grandement les fonctionalités disponibles pour les programmes Tcl qui seraient éxecutés. Permettre à du code Tcl non fiable un accès direct à ces fonctionalités est dangeureux, parce que il peut être utilisé pour un grand nombre d'attaques sur l'environnement. Néanmoins, il y a parfois un besoin legitime d'utiliser les fonctionalités dangereuses dans le contexte de l'interpréteur sùr. Par exemple, parfois un programme doit être <A HREF="163.htm"><b>source</b></A>d dans l'interpréteur. Un autre exemple est Tk, ou des fenêtres sont attachées à une hiérarchie de fenêtres pour un interpréteur spécifique; quelque potentiellement dangereuse fonctions, ex. gestion de fenêtres, doit être effectuée sur ces fenêtres dans le contexte de l'interpréteur. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">La commande <b>interp</b> fournit une solution à ce problème sous la forme des <i>hidden commands</i>. Au lieu d'enlever entièrement les commandes dangereuses d'un interpréteur sùr, ces commandes sont cachées donc elles deviennent indisponibles pour les l'exécution de scripts Tcl dans l'interpréteur. Néanmoins, ces commande cachées peuvent être appelée par ancêtre fiable de l'interpréteur sùr, dans le contexte de l'interpréteur sùr, en utilisant <b>interpinvoke</b>. Les commandes cachées et commandes visibles résident dans des namespaces séparés. Il est possible de definir une commande cachée et un commande visible portant les même nom dans un interpréteur. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">Les commandes cachées dans un interpréteur esclave peuvent être appelées dans le corps des fonctions appelées dans le maître pendant l'appel d'alias. Par exemple, un alias de <A HREF="163.htm"><b>source</b></A> pourrait être créé dans un interpréteur esclave. Quand elle est appelée dans l'interpréteur esclave, une fonction est appelée dans le maître interpréteur pour vérifier si l'opération est autorisée (ex. il demande de <i>sourcer</i> un fichier que l'interpréteur esclave est autorisé à accéder). La fonction alors appelle la commande <A HREF="163.htm"><b>source</b></A> cachée dans l'interpréteur esclave pour <i>sourcer</i> le contenu du fichier. Notez que deux commandes nommées <A HREF="163.htm"><b>source</b></A> existent dans l'interpréteur esclave: l'alias, et la commande cachée. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">Parcequ'un interpréteur maître peut appeller une commande cachée comme partie de la gestion d'un appel d'alias, grans soin doit être pris d'éviter l'évalualuation de tout arguments transmis au travers de l'appel de l'alias. Autrement, un interpréteur esclave malin pourrait faire exécuter à l'interpréteur maître de confiance des commandes dangereuses. Voir la section sur l' APPEL D'ALIAS pour une discussion plus complète de ce topic. Pour aider à éviter ce problème, aucune substitutions ou évaluations ne sont appliquées aux arguments de <b>interp </b><b>invokehidden</b>. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">Les interpréteurs sùrs ne sont pas autorisés à appeler des commande cachées dans eux-mêmes ou dans leurs descendants. Ceci empêche les esclaves sùr d'acceder aux fonctionalité cachées dans eux-mêmes ou leurs descendants. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">L'ensemble des commandes cachées dans un interpréteur peut être manipulé par un interpréteur de confiance en utilisant <b>interp expose</b> et <b>interp hide</b>. La commande <b>interp expose</b> déplace une commande cachée dans le jeu de commande visibles dans l'interpréteur identifié par <i>path</i>, potentiellement renommant la commande dans le processus. Si une commande visible du nom ciblé existe déjà, l'opération échoue. Pareillement, <b>interp hide</b> déplace une commande visible dans le jeu de commande cachées dans cet interpréteur. Les interpréteurs sùrs ne sont pas autorisés à déplacer les commandes entre l'ensemble des commandes cachées et visibles, dans soit eux-même ou leurs descendants. </div>
<div ALIGN="LEFT" style="margin-left: 51px;">Actuellement, les noms des commande cachées ne peuvent pas contenir de qualificateurs namespace, et vous devez en premier renommer une commande d'un namespace dans le namespace global avant de pouvoir la cacher. Les commandes cachées par <b>interp hide</b> sont recherchée dans le namespace global même si le namespace courant n'est pas le global. Ceci empêche les esclaves d'abuser un maître interpréteur en cachant les mauvaises commandes, en rendant le namespace courant différent du global. 
</div><br>
<div><b>CREDITS</b></div><br>
<div ALIGN="LEFT" style="margin-left: 51px;">Ce mécanisme est basé sur le prototype Safe-Tcl implémenté par Nathaniel Borenstein et Marshall Rose 
</div><br>
<div><b>VOIR EGALEMENT</b></div><br>
<div ALIGN="LEFT" style="margin-left: 51px;"><A HREF="134.htm">load</A>(n), safe(n), Tcl_CreateSlave(3) </div>
<div>Dernière révision: 7.6</div>
<br>
<br><div ALIGN="CENTER"><A HREF="index.htm"><b>Index</b></A>&nbsp;&nbsp;<A HREF="125.htm"><b>Précédent</b></A>&nbsp;&nbsp;<A HREF="127.htm"><b>Suivant</b></A></div>
</BODY></HTML>
